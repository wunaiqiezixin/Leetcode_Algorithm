# P0230:N皇后问题
[题目链接](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0230/)

---
### 用递归代替多重循环
* 如果两个皇后棋子在同一行、同一列，或者在某个正方形的对角线上，那么这两个皇后就会互相攻击
* 每一行只能摆放一个皇后, queenPos[i] 表示皇后摆放在 第i行， 第queenPos[i]列
* 定义函数
```C
void NQueen(int k, _Bool* isExist)
//表示在前k-1行的皇后已经摆放好的情况下，摆放第K行及以后的皇后
// isExist 表示是否存在摆放结果
```
* 如果 k == N,则说明所有皇后都已经摆好了，输出之
* 否则考虑摆放第k行及其以后的皇后
* 对于第k行的皇后，我们逐一判断第0列到第N-1列是否符合要求，即要与前k-1行的皇后位置进行比较
* 不能位于同一列
* 不能处于某个正方形的对角线上-->行之差 不能等于 列之差
* 如果找到了第k行皇后的位置，则递归调用NQueen(k + 1, isExist)

### ***C***
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define MAX_SIZE 100
int fabs(int n)
{
	return n > 0 ? n : -n;
}
int N;
int queenPos[MAX_SIZE];

void NQueen(int k,_Bool* isExist); //在前k-1行皇后已经摆放好的情况下,摆放第k行及以后的皇后

int main(void)
{
	scanf("%d", &N);
	_Bool flag = 0;
	NQueen(0,&flag);
	if (!flag) printf("NO ANSWER");
}

void NQueen(int k,_Bool* isExist)
{
	if (k == N)
	{
		*isExist = 1;
		int i;
		for (i = 0; i < N; i++)
		{
			printf("%d ", queenPos[i]);
		}
		printf("\n");
		return;
	}

	//摆放第k行的皇后
	int col;
	for (col = 0; col < N; col++)
	{
		int i;
		for (i = 0; i < k; i++) /*将第col列位置与前K-1行的皇后比较*/
		{
			if (queenPos[i] == col || fabs(queenPos[i] - col) == fabs(k - i))
			{
				break;
			}
		}
		if (i == k) //说明col列与前K-1行的皇后均不冲突
		{
			queenPos[k] = col;
			NQueen(k + 1,isExist); //第k行已经摆放好，摆放第k+1行及以后的皇后
		}
	}
}
```
