# P0260:上台阶
[题目链接](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0260/)

### 🚀用递归思想将问题进行分解

- 定义函数 stairs()
```C
int stairs(int n);
//输入台阶的级数n, 输出走法的总数
```
- 根据函数，我们来思考用递归解决问题
- 要走n级台阶，我们首先要迈出第一步
- 第一步，可以走一级台阶，那么对于剩下的台阶，总的走法数就是stairs(n - 1)
- 第一步，也可以走两级台阶，那么对于剩下的台阶，总的走法数就是stairs(n - 2)
- 因此，**n级台阶的走法数 = n-1阶台阶的走法数 + n-2阶台阶的走法数**
- 我们很惊喜的发现，通过先做一步，再分析问题，我们就把问题分解了。问题的形式完全一致，但是规模变小了，这就是分治的思想。通过不断地分解问题，最终得到规模足够小的问题，我们可以不用递归就能解决，即递归的边界
- 那么对于本题递归的边界是什么呢？
- 可以是 n = 1 和 n = 2 : 一级台阶，只有1种走法；两级台阶有2种走法
### 完整代码
### ***C:***
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int stairs(int n)
{
	//递归的边界：
	if (n == 1) return 1;
	if (n == 2) return 2;
	//将问题进行分解
	return stairs(n - 1) + stairs(n - 2);
}

int main(void)
{
	int N;
	scanf("%d", &N);
	printf("%d", stairs(N));
}
```

---
但是时间复杂度是 $O(2^n)$

- 因为有大量的重复计算
- 我们可以将已经计算得到结果的用一个memo数组记下来
### 📝避免重复计算
```C
long long memo[101] = { 0 };//将数组初始化为0，方便知道是否已经计算过
long long memo_stairs(int n)
{
	if (memo[n])//如果已经计算过了，直接用
		return memo[n];
	if (n == 1)
		memo[n] = 1;
	else if (n == 2)
		memo[n] = 2;
	else
	{
		memo[n - 1] = memo_stairs(n - 1);
		memo[n - 2] = memo_stairs(n - 2);
		memo[n] = memo[n - 1] + memo[n - 2];
	}
	return memo[n];
}
```

### 完整代码_memo
### ***C:***
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

long long memo[101] = { 0 };
long long memo_stairs(int n)
{
	if (memo[n])
		return memo[n];
	if (n == 1)
		memo[n] = 1;
	else if (n == 2)
		memo[n] = 2;
	else
	{
		memo[n - 1] = memo_stairs(n - 1);
		memo[n - 2] = memo_stairs(n - 2);
		memo[n] = memo[n - 1] + memo[n - 2];
	}
	return memo[n];
}

int main(void)
{
	int n;
	scanf("%d", &n);
	printf("%lld", memo_stairs(n));
}
```
