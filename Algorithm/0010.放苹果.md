# P0280:放苹果
[题目链接](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0280/)

### 用递归思想将问题分解
---

- 定义函数
```C
//把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放
//f()返回分法总数
int f(int M, int N);
```
- main()函数
```C
int main(void)
{
	int t; //测试数据的组数
	scanf("%d", &t);
	while (t--)
	{
		int m, n;
		scanf("%d %d", &m, &n);
		printf("%d\n", f(m, n));
	}
}
```
- 来看f()函数，这是关键
#####  如果盘子数N大于苹果数M
- 则至少有(N - M)个盘子没有存在的价值,问题等价于 **把M个同样的苹果放在M个同样的盘子里**
```C
return f(M,M);
```
#####  如果盘子数N小于等于苹果数M
- 我们将问题进行分类，这个思想是非常重要的，将大问题拆解为多个小的子问题，分而治之
- ***第一类***：有空盘子的情况
- 则至少要保证有一个空盘子，即我们已经确定了有一个盘子要丢弃，这种情况下，问题变为，把M个同样的苹果放在N-1个同样的盘子里。我们将问题的规模缩小了
```C
f(M,N-1)
```
- ***第二类***：无空盘子的情况
- 则每一个盘子必须放至少一个苹果，也就是说，有N个苹果已经确定了。我们只需考虑剩下的(M - N)个苹果的分法。问题等价于把(M - N)个同样的苹果放在N个同样的盘子里
```C
f(M - N,N)
```
###### 最终分法总数为 $$f(M, N - 1) + f(M - N, N)$$
```C
return f(M, N - 1) + f(M - N, N);
```

### 完整的f()函数
```C
int f(int M, int N)
{
	//递归的边界：
	if (M == 0) return 1;
	if (N == 0) return 0;

	//如果盘子数大于苹果数，则至少有(N - M)个空盘子
	if (N > M) return f(M, M);
	//如果盘子数小于等于苹果数
	//我们将问题分类：1.有空盘子的情况  2.无空盘子的情况
	return f(M, N - 1) + f(M - N, N);
}
```

### 完整代码
### ***C：***
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放
//f()返回分法总数
int f(int M, int N)
{
	//递归的边界：
	if (M == 0) return 1;
	if (N == 0) return 0;

	//如果盘子数大于苹果数，则至少有(N - M)个空盘子
	if (N > M) return f(M, M);
	//如果盘子数小于等于苹果数
	//我们将问题分类：1.有空盘子的情况  2.无空盘子的情况
	return f(M, N - 1) + f(M - N, N);
}

int main(void)
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		int m, n;
		scanf("%d %d", &m, &n);
		printf("%d\n", f(m, n));
	}
}
```
