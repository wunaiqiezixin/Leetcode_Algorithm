# P0270:算24
[题目链接](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0270/)

- 除法定义是实数除法,所以我们用doubel类型的数组存放数字
- 因此，对于1/5等无法除尽的情况，会造成浮点数损失。
- 我们需要定义一个很小的数EPS和函数isZero()来判断两个浮点数是否相等。若它们相减小于EPS,则表明它们相等
```C
#define EPS 1e-6
bool isZero(doubel a)
{
    return fabs(a) <= EPS;
}
```
- 定义函数
```C
bool count24(double* a, int n);
//判断a数组中的n个数字能否算出24
```
- main()函数
```C
int main(void)
{
    doubel a[5];
    int flag = 0;//用于判断每四个数中，0的个数
    int i;
    while (true)
    {
        for (i = 0;i < 4;i++)
        {
            scanf("%lf", &a[i]);
            if (a[i] == 0) flag++;
        }
        if (flag == 4) break;
        flag = 0;

        if (count24(a, 4) printf("YES");
        else printf("NO");
}
```
- 递归
- 我们可以先做一步，然后可能会发现问题的规模减小、形式不变
- 先从n个数中随机取出2个数，把这两个数做运算(+ - * /), 再把运算的结果放回。于是，我们就已经完成了一步(当然，我们要枚举第一步的所有可能)
- 我们再来看问题，我们现在只要判断(n - 1)个数中能否算出24。规模减小
- 递归的边界：当规模减小为1时，我们就可以直接判断能否从这个数中算出24，即判断这个数是否等于24
```C
if (n == 1) return isZero(a[0] - 24);
```
- 我们再来仔细考虑怎么用代码实现
- **首先** 从n个数中选出两个数
```C
int i, j;
for (i = 0;i < n - 1;i++)
{
    for (j = i + 1;j < n;j++)
    {
        //两个数为：a[i] ,  a[j]
    }
}
```
- **其次**我们还应该有另外一个数组b存放剩余的n - 2个数和取出的两个数的运算结果，用于下一次的递归
```C
double b[5];//数组b
int m;//用于表示数组b的长度
int i, j;
for (i = 0;i < n - 1;i++)
{
    for (j = i + 1;j < n;j++)
    {
        //两个数为：a[i] ,  a[j]
        m = 0;
        int k;//把剩下的n - 2个数放入b
        for (k = 0;k < n;k++)
        {
            if (k != i && k != j)
            {
                b[m++] = a[k];
            }
        }
        
    }
}
```
- **最后**把取出的两个数的运算结果放入b,枚举四种运算情况。注意减法，除法要特别考虑。递归
```C

			b[m] = a[i] + a[j];
			if (count24(b, m + 1)) return true;
			b[m] = a[i] - a[j];
			if (count24(b, m + 1)) return true;
			b[m] = a[j] - a[i];
			if (count24(b, m + 1)) return true;
			b[m] = a[i] * a[j];
			if (count24(b, m + 1)) return true;
			if (!isZero(a[j]))
			{
				b[m] = a[i] / a[j];
				if (count24(b, m + 1)) return true;
			}
			if (!isZero(a[i]))
			{
				b[m] = a[j] / a[i];
				if (count24(b, m + 1)) return true;
       }
```



### 完整代码
### ***C:***
```C
#define _CRT_SECURE_NO_WARNINGS
#define EPS 1e-6
#include<stdio.h>
#include<stdbool.h>
#include<math.h>
//用于浮点数的比较
bool isZero(double num)
{
	return fabs(num) <= EPS;
}
//count24()表示数组a中的n个数是否能算出24
bool count24(double* a, int n)
{
	//边界条件
	if (n == 1) return isZero(a[0] - 24);
	//先挑选出两个数，让他们做计算，将剩余的数和这两个数计算的结果放在数组b中
	double b[5];
	int m;      //数组b及元素个数
	int i, j;
	for (i = 0; i < n - 1; i++)
	{
		for (j = i + 1; j < n; j++)
		{
			m = 0; //数组b的元素个数初始化为0
			/* 将剩余元素加入到b */
			int k;
			for (k = 0; k < n; k++)
			{
				if (k != i && k != j) b[m++] = a[k];
			}
			/* 将两个数运算的值加入到b */
			/* 以b为新的数组进行递归 */
			b[m] = a[i] + a[j];
			if (count24(b, m + 1)) return true;
			b[m] = a[i] - a[j];
			if (count24(b, m + 1)) return true;
			b[m] = a[j] - a[i];
			if (count24(b, m + 1)) return true;
			b[m] = a[i] * a[j];
			if (count24(b, m + 1)) return true;
			if (!isZero(a[j]))
			{
				b[m] = a[i] / a[j];
				if (count24(b, m + 1)) return true;
			}
			if (!isZero(a[i]))
			{
				b[m] = a[j] / a[i];
				if (count24(b, m + 1)) return true;
			}
		}
	}
	return false;
}

double a[5];
int main(void)
{
	int flag = 0;
	while (true)
	{
		int i;
		for (i = 0; i < 4; i++)
		{
			scanf("%lf", &a[i]);
			if (isZero(a[i])) flag++;
		}
		if (flag == 4) break;
		flag = 0;

		if (count24(a, 4)) printf("YES\n");
		else printf("NO\n");
	}
}
```
