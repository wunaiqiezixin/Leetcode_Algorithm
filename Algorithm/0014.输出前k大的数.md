# P0400:输出前k大的数
[题目链接](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0400/)

---
### 最直接的想法---对整个数组进行排序--O(nlogn)
- 采用快速排序的方法，一般情况下，复杂度为O(nlogn)
```C
void swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
//快速排序
void quickSort(int* ar, int s, int e)
{
	if (s >= e) return; //边界
	int K = ar[s]; //将大于k的放一边，小于k的放一边
	int left = s, right = e;
	while (left != right)
	{
		//用小于K的数填充左边的坑
		while (left < right && ar[right] >= K)
			right--;
		swap(&ar[left], &ar[right]);
		//用大于K的数填充右边的坑
		while (left < right && ar[left] <= K)
			left++;
		swap(&ar[left], &ar[right]);
	}
	quickSort(ar, s, left - 1);
	quickSort(ar, left + 1, e);
}
```
> 但是我们对整个数组进行了排序，这是很浪费时间的，如果我们能先把前K个大的数全部放到右边，再对这K个数进行排序，会好很多
> 我们要做的就是想办法用O(n)的时间将前K个大的数放到数组的右边
### 分治
>我们可以参考快速排序的做法，先选定一个基准数，一般是数组的第一个数，然后将大于基准数的放右边，小于基准数的放左边
- 函数toRight()用于将前k个大的数放到数组的右边
```C
//将前K大的元素移动到右边
void toRight(int* ar, int s, int e, int k)
{
	int tmp = ar[s];
	int left = s, right = e;
	while (left != right)
	{
		//用比tmp小的元素填左边的坑
		while (left < right && ar[right] >= tmp)
			right--;
		swap(&ar[left], &ar[right]);
		//用比tmp大的元素填右边的坑
		while (left < right && ar[left] <= tmp)
			left++;
		swap(&ar[left], &ar[right]);
	}
	//将数组划分为两部分后，判断右半部分的长度与K的大小
	int size = e - left + 1;
	//相等，说明前K大的元素全部在右边了，返回
	if (size == k) return;
	//小于，从左半部分再找(k - size)个元素
	else if (size < k) toRight(ar, s, left - 1, k - size);
	//大于，从右半部分再次挑选处K个最大的放到右边
	else toRight(ar, left + 1, e, k);/*注意从left + 1开始*/
}
```
- 最后，我们只需要对数组的后K个数进行排序，然后从大到小输出它们
```C
int nums[100000];
int main(void)
{
	int N;
	scanf("%d", &N);
	int i;
	for (i = 0; i < N; i++)
	{
		int n;
		scanf("%d", &n);
		nums[i] = n;
	}
	int k;
	scanf("%d", &k);
	//将前K大的元素放到数组右边--> O(n)
	toRight(nums, 0, N - 1, k);
	//对右边的K个元素快速排序--> O(klogk)
	quickSort(nums, N - k, N - 1);
	for (i = N - 1; i >= N - k; i++)
		printf("%d\n", nums[i]);
}
```
> 时间复杂度为 O(n + klogk)
