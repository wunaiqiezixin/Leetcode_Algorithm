# P0300:求排列的逆序数
[题目链接](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0300/)

---
### 先来复习一下归并排序
```C
//归并排序：从大到小
/*将两个有序部分合并为一个有序序列*/
void merge(int* ar, int s, int e, int* tmp)
{
	int mid = s + (e - s) / 2;
	/*合并s~mid和mid+1~e*/
	int p = 0, p1 = s, p2 = mid + 1;
	while (p1 <= mid && p2 <= e)
	{
		if (ar[p1] > ar[p2]) tmp[p++] = ar[p1++];
		else tmp[p++] = ar[p2++];
	}
	while (p1 <= mid) tmp[p++] = ar[p1++];
	while (p2 <= e) tmp[p++] = ar[p2++];
	for (int i = 0; i < e - s + 1; i++)
		ar[s + i] = tmp[i];

}
/*将下标s~e的元素进行排序*/
void mergeSort(int* ar, int s, int e, int* tmp)
{
	if (s < e)
	{
		int mid = s + (e - s) / 2;
		mergeSort(ar, s, mid, tmp);
		mergeSort(ar, mid + 1, e, tmp);
		merge(ar, s, e, tmp);
		return;
	}
	return;
}
```
>归并排序是分治思想的典型应用
>
>将区间一分为二，分别对两个区间进行排序，在将两个有序的区间合并
>
>本题可以借助归并排序的思路:
>1. 将区间一分为二，分别求出两个区间的逆序数
>2. 再求出来自两个区间的逆序数
---
### main()函数
>我们将ans作为全局变量，初始化为0，来记录逆序数的总数
>
>将ans的地址传入递归函数，对全局变量ans进行累加，最后得到逆序数的总数
>
>结果可能会溢出，所以ans用long long类型来声明
```C
int main(void)
{
	int N;
	scanf("%d", &N);
	int i;
	for (i = 0; i < N; i++)
	{
		int n;
		scanf("%d", &n);
		nums[i] = n;
	}
  //get_num()将逆序数总数累加到ans上
	get_num(nums, 0, N - 1, &ans);
	printf("%lld", ans);
}
```
### get_num()函数
```C
//get_num()函数累加逆序数的个数到ans上
void get_num(int* ar, int s, int e, int* ans)
{
	if (s >= e) return;/*数组元素小于等于1*/
	if (e - s == 1)/*数组元素只有两个，我们只需判断它们的大小*/
	{
		*ans += ar[s] <= ar[e] ? 0LL : 1LL;
		return;
	}
	//一分为二
	int mid = s + (e - s) / 2;
	get_num(ar, s, mid, ans);
	get_num(ar, mid + 1, e, ans);
	//get_cross_num()来自左右两个区间的逆序数
	get_cross_num(ar, s, e, ans);
}
```
### get_cross_num()函数
```C
void get_cross_num(int* ar, int s, int e, int* ans)
{
	int mid = s + (e - s) / 2;
	//将左区间s~mid,右区间mid+1~e分别从大到小排序
	quickSort(ar, s, mid);
	quickSort(ar, mid + 1, e);
	//累加逆序数的个数到ans上
	int left = s, right = mid + 1;
	while (left <= mid && right <= e)
	{
		while (right <= e && ar[right] >= ar[left])
			right++;
		*ans += e - right + 1;
		left++;
	}
}
```

### 完整代码
### ***C:***
```C
#define _CRT_SECURE_NO_WARNINGS
#define MAX_SIZE 100000
#include<stdio.h>
int nums[MAX_SIZE];
long long ans = 0; //记录逆序数的总个数
void swap(int* a, int* b)
{
	int t = *a;
	*a = *b;
	*b = t;
}
//快速排序
void quickSort(int* ar, int s, int e)
{
	if (s >= e) return;
	int tmp = ar[s];
	int left = s, right = e;
	while (left != right)
	{
		//用大于tmp的数来填充左边的坑
		while (left < right && ar[right] <= tmp)
			right--;
		swap(&ar[left], &ar[right]);
		//用小于tmp的数来填充右边的坑
		while (left < right && ar[left] >= tmp)
			left++;
		swap(&ar[left], &ar[right]);
	}
	quickSort(ar, s, left - 1);
	quickSort(ar, left + 1, e);
}
void get_cross_num(int* ar, int s, int e, int* ans)
{
	int mid = s + (e - s) / 2;
	//将左区间s~mid,右区间mid+1~e分别从大到小排序
	quickSort(ar, s, mid);
	quickSort(ar, mid + 1, e);
	//累加逆序数的个数到ans上
	int left = s, right = mid + 1;
	while (left <= mid && right <= e)
	{
		while (right <= e && ar[right] >= ar[left])
			right++;
		*ans += e - right + 1;
		left++;
	}
}
//get_num()函数累加逆序数的个数到ans上
void get_num(int* ar, int s, int e, int* ans)
{
	if (s >= e) return;
	if (e - s == 1)
	{
		*ans += ar[s] <= ar[e] ? 0LL : 1LL;
		return;
	}
	//一分为二
	int mid = s + (e - s) / 2;
	get_num(ar, s, mid, ans);
	get_num(ar, mid + 1, e, ans);
	//get_cross_num()来自左右两个区间的逆序数
	get_cross_num(ar, s, e, ans);
}

int main(void)
{
	int N;
	scanf("%d", &N);
	int i;
	for (i = 0; i < N; i++)
	{
		int n;
		scanf("%d", &n);
		nums[i] = n;
	}
	get_num(nums, 0, N - 1, &ans);
	printf("%lld", ans);
}
```
