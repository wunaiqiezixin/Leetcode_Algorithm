# 1. 两数之和
[力扣题目链接](https://leetcode.cn/problems/two-sum/description/)

### 枚举法两个数的所有组合
### ***C:***
```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    *returnSize = 2;
    int* ans = (int*)malloc(sizeof(int) * 2);
    //枚举两个数的所有组合
    int i;
    for (i = 0;i < numsSize - 1;i++)
    {
        int j;
        for (j = i + 1;j < numsSize;j++)
        {
            if (nums[i] + nums[j] == target)
            {
                ans[0] = i;
                ans[1] = j;
                break;
            }
        }
    }
    return ans;
}
```
---
### 哈希法
- 定义一个哈希表
```C
#define HASH_SIZE 101
//哈希表
typedef struct node {
    int val;
    int idx;
    struct node* next;
}node, *HashMap;

//哈希表的初始化
node** hash_init()
{
    node** hashmap = (node**)malloc(sizeof(node) * HASH_SIZE);
    for (int i = 0; i < HASH_SIZE; i++)
    {
        hashmap[i] = (node*)malloc(sizeof(node));
        hashmap[i]->next = NULL;//让其指向NULL，避免出现野指针
    }
    return hashmap;
}

//哈希函数
int hash_func(int val)
{
    return abs(val) % HASH_SIZE;
}

//哈希表的插入
void hash_insert(HashMap hashmap[], int val, int idx)
{
    int index = hash_func(val);
    node* p = hashmap[index];
    //本题不用考虑，插入元素已经在内的情况，直接找尾结点
    while (p->next) p = p->next;
    node* new = (node*)malloc(sizeof(node));
    new->val = val;
    new->idx = idx;
    new->next = NULL;
    p->next = new;
    return;
}

//哈希表的查找
int hash_search(HashMap hashmap[], int val)
{
    //返回数组下标索引
    int index = hash_func(val);
    node* p = hashmap[index];
    while (p->next)
    {
        p = p->next;
        if (p->val == val) return p->idx;
    }
    return -1;//不在，返回-1
}
```
- 用哈希表存储遍历过的元素的***值***和***下标***，每每遍历到一个元素都要看看(target - nums[i])是不是已经遍历了
```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    *returnSize = 0;
    int* ans = (int*)malloc(sizeof(int) * 2);
    //初始化哈希表
    node** hashmap = hash_init();
    //遍历数组，用哈希表来存储已经遍历的值
    for (int i = 0; i < numsSize; i++)
    {
        int flag = hash_search(hashmap, target - nums[i]);
        if (flag != -1)
        {
            ans[(*returnSize)++] = i;
            ans[(*returnSize)++] = flag;
        }
        hash_insert(hashmap, nums[i], i);
    }
    return ans;
}
```
---
### 使用Python字典
- 使用visited字典，记录已经遍历过的元素，key为元素的值，value为元素的下标
```Python
visited = dict()
```
- 只需遍历一次数组,使用enumerate
- 每遍历到一个数组元素，判断target与它的差是否在visited中
```Python
for i,num in enumerate(nums):
      d = target - num
      if d in visited:
            return [i,visited[d]]
      visited[num] = i
```
### 完整代码
### ***Python:***
```Python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        #使用字典，来存储已经遍历过的元素
        visited = dict()
        #只要遍历一次数组
        for i,num in enumerate(nums):
            d = target - num
            #判断d是否已经遍历过
            if d in visited:
                return [i,visited[d]]
            #若没有，则将num加入字典
            visited[num] = i
```
