# 20. 有效的括号
[力扣题目链接](https://leetcode.cn/problems/valid-parentheses/description/)

---
### 🧠本题特别适合用栈处理
>遍历字符串  
>遇到左括号就入栈 
>遇到右括号，先判断栈是否为空，若为空，则返回false  
>如果栈不为空，再看是否与栈顶括号匹配  若不匹配返回false，匹配则弹出栈顶括号
>遍历完字符串后，若栈为空，则字符串合法
### 📝用单向链表实现栈
>我们先设定一个虚拟头节点  
>一定要将链表的头节点作为栈的顶部  
>因为只有这样，push和pop操作的时间复杂度都是 $O(1)$ 的

### 💻完整代码
### ***C:***
```C
//用链表来实现一个栈
typedef struct node {
    char c;
    struct node* next;
} node;

char Pairs(char c)
{
    switch (c)
    {
        case '}':
            return '{';
        case ']':
            return '[';
        case ')':
            return '(';
    }
    return '0';//不加这一行，力扣不给通过
}

//遇到左括号就入栈
//遇到右括号判断栈是否为空，以及是否与栈顶元素匹配
bool isValid(char* s) {
    //虚拟头节点
    node* dummy = (node*)malloc(sizeof(node));
    dummy->next = NULL;
    //遍历字符串
    int i;
    for (i = 0; i < strlen(s); i++)
    {
        switch (s[i])
        {
            case '[':
            case '{':
            case '(':
                node* new = (node*)malloc(sizeof(node));
                new->c = s[i];
                new->next = dummy->next;
                dummy->next = new;
                break;
            default:
                if (dummy->next == NULL || Pairs(s[i]) != dummy->next->c)
                    return false;
                else
                {
                    node* cur = dummy->next;
                    dummy->next = dummy->next->next;
                    free(cur);
                }
        }
    }
    return dummy->next == NULL;
}
```
