# 59.螺旋矩阵II
[力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)

* 先看懂力扣给的提示及函数原型

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
    
}
```
* int* returnSize 一级指针
* int** returnColumnSize 二级指针
* 将一级指针作为参数传入函数可以修改一个变量
* 将二级指针作为参数传入函数可以允许函数内部“分配内存”并“返回” **整个数组或整个复杂数据结构**
* ***替代方案***：对于逻辑上紧密相关的多个数据，将其*封装*在一个结构体（struct)​中，然后让函数返回这个结构体实例，通常是更优雅、可读性更好的选择。**应避免使用全局变量**来模拟多返回值，这会增加程序的耦合度和不可预测性。
* 注意释放内存

## 思路
* 关键在于模拟螺旋填充过程
* 一共要循环n/2圈，若n为奇数，在循环晚n/2圈后，还要填充中间的一个元素
* 在循环每一圈的时候，进行四次for循环，依次填充正方形四条边，每次循环都应遵循左闭右开，即最右边的元素不填充，留给下一条边去填充
* 声明 int startx = 0,starty = 0 为每一圈的填充起始位置，第startx行，第starty列，每填充完一圈后，startx++，starty++
* 声明 int i,j 表示第i行第j列，用于循环填充每一条边
* 声明 int offset = 1 表示圈的规模变小，也确保左闭右开进行填充每一条边，每填充完一圈 offset++
* 在每一圈填充中关注i,j的值，合理利用 


### ***C***
```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
    *returnSize = n;
    *returnColumnSizes = (int*)malloc(sizeof(int) * n);
    int** ans = (int**)malloc(sizeof(int*) * n);
    for (int i = 0;i < n;i++)
    {
        (*returnColumnSizes)[i] = n;
        ans[i] = (int*)malloc(sizeof(int) * n);
    }
    int startx = 0,starty = 0;
    int count = 1,offset = 1,loop = n / 2;
    int i,j;
    while (loop)
    {
        
    for (j = starty;j < n - offset;j++)
    {
        ans[startx][j] = count++;
    }
    for (i = startx;i < n - offset;i++)
    {
        ans[i][j] = count++;
    }
    for (;j > starty;j--)
    {
        ans[i][j] = count++;
    }
    for (;i > startx;i--)
    {
        ans[i][j] = count++;
    }
    startx++;
    starty++;
    offset++;
    loop--;
    }
    if (n % 2)
    {
        ans[n/2][n/2] = count;
    }
    return ans;
}
```
