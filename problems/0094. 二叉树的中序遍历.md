# 94. 二叉树的中序遍历
## 递归遍历二叉树
先遍历左子树，再遍历根节点，最后遍历右子树  
递归解决
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

//递归解决：
void infixOrder(struct TreeNode* root, int* ret, int* retSize)
{
    //递归的边界
    if (root == NULL)
        return;
    //先遍历左子树
    infixOrder(root->left, ret, retSize);
    //再遍历根节点
    ret[(*retSize)++] = root->val;
    //最后遍历右子树
    infixOrder(root->right, ret, retSize);
}
int* inorderTraversal(struct TreeNode* root, int* returnSize) {
    *returnSize = 0;
    int* ret = (int*)malloc(sizeof(int) * 100);
    infixOrder(root, ret, returnSize);
    return ret;
}
```
