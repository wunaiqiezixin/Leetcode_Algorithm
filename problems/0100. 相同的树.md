# 100. ç›¸åŒçš„æ ‘
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/same-tree/description/)

---
æœ¬é¢˜æ˜¯[0101.å¯¹ç§°äºŒå‰æ ‘](https://github.com/wunaiqiezixin/Leetcode_Algorithm/blob/main/problems/0101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md)é€çš„
## ğŸ“é€’å½’
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if (!p && !q)
        return true;
    else if ((!p && q) || (p && !q) || (p->val != q->val))
        return false;
    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```
## ğŸè¿­ä»£æ³•
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    //é˜Ÿåˆ—
    struct TreeNode** que = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 1000);
    int front = 0, rear = 0;
    //å…¥é˜Ÿ
    que[rear++] = p;
    que[rear++] = q;
    //è¿­ä»£
    while (front < rear)
    {
        //å‡ºé˜Ÿ
        struct TreeNode* left = que[front++];
        struct TreeNode* right = que[front++];
        if (!left && !right) 
            continue;
        else if ((!left && right) || (left && !right) || (left->val != right->val))
            return false;
        //å…¥é˜Ÿ
        que[rear++] = left->left;
        que[rear++] = right->left;
        que[rear++] = left->right;
        que[rear++] = right->right;
    }
    return true;
}
```
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    //æ ˆ
    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNdoe*) * 1000);
    int stackTop = 0;
    //å…¥æ ˆ
    stack[stackTop++] = p;
    stack[stackTop++] = q;
    //è¿­ä»£
    while (stackTop)
    {
        //å‡ºæ ˆ
        struct TreeNode* right = stack[--stackTop];
        struct TreeNode* left = stack[--stackTop];
        //åˆ¤æ–­
        if (!right && !left)
            continue;
        else if ((!left && right) || (left && !right) || (left->val != right->val))
            return false;
        //å…¥æ ˆ
        stack[stackTop++] = left->left;
        stack[stackTop++] = right->left;
        stack[stackTop++] = left->right;
        stack[stackTop++] = right->right;
    }
    return true;
}
```
