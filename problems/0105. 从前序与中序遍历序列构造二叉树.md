# 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

---
## ğŸ“æ•°ç»„ä½œä¸ºå‡½æ•°çš„å½¢å¼å‚æ•°
æ•°ç»„ä½œä¸ºå‡½æ•°çš„å½¢å¼å‚æ•°ï¼Œä¼ ç»™å‡½æ•°çš„æ˜¯æ•°ç»„çš„é¦–å…ƒç´ çš„åœ°å€   
ä½†æ˜¯æˆ‘ä»¬åªçŸ¥é“èµ·ç‚¹ï¼Œå¹¶ä¸çŸ¥é“ç»ˆç‚¹ï¼Œè¿˜ä¸èƒ½æ˜ç¡®ä¸€ä¸ªæ•°ç»„ï¼Œå› æ­¤ï¼Œé€šå¸¸è¿˜è¦å°†æ•°ç»„çš„é•¿åº¦ä¹Ÿä¼ å…¥å‡½æ•°   
æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆè®¤ä¸ºï¼šå‡½æ•°ä¸­ä¸€ä¸ªæ•°ç»„ç”±é¦–å…ƒç´ åœ°å€å’Œé•¿åº¦å”¯ä¸€ç¡®å®š   
äºæ˜¯æˆ‘ä»¬åªè¦å¯¹æ•°ç»„å(é¦–å…ƒç´ åœ°å€)è¿›è¡ŒæŒ‡é’ˆè¿ç®—ï¼Œå†è®¡ç®—é•¿åº¦ï¼Œå°±å¯ä»¥å®ç°"åˆ†å‰²æ•°ç»„"   
å³å°†æ•°ç»„ä¸€åˆ†ä¸ºäºŒ

# ğŸ§ æ€è·¯
ä»å‰åºåºåˆ—æ‰¾æ ¹èŠ‚ç‚¹ï¼Œåˆ†å‰²ä¸­åºåºåˆ—   
1. åˆ¤æ–­æ•°ç»„æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œè¯´æ˜ä¸ºç©ºèŠ‚ç‚¹ï¼Œè¿”å›NULL
2. å¦‚æœä¸ä¸ºç©ºï¼Œæ„å»ºä¸€ä¸ªèŠ‚ç‚¹rootï¼Œå€¼ä¸ºå‰åºæ•°ç»„é¦–å…ƒç´ çš„å€¼
3. åœ¨ä¸­åºæ•°ç»„ä¸­æŸ¥æ‰¾rootçš„å€¼å¯¹åº”çš„ä¸‹æ ‡index
4. ä»¥indexä¸ºç•Œå°†ä¸­åºæ•°ç»„ä¸€åˆ†ä¸ºäºŒ(ä¸¢å¼ƒindexå¯¹åº”çš„å€¼)
5. æ ¹æ®ä¸­åºæ•°ç»„å·¦å³åŒºé—´çš„é•¿åº¦ï¼Œç»§ç»­å°†å‰åºæ•°ç»„ä¸€åˆ†ä¸ºäºŒ(ä¸¢å¼ƒé¦–å…ƒç´ )
6. é€’å½’

å®Œæ•´ä»£ç ï¼š
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {
    //å¦‚æœæ•°ç»„ä¸ºç©º,ä¸ºç©ºèŠ‚ç‚¹
    if (inorderSize == 0) return NULL;
    //ä¸ä¸ºç©ºï¼Œå–å‰åºç¬¬ä¸€ä¸ªå…ƒç´ 
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val = *preorder;
    //æ‰¾ä¸­åºæ•°ç»„çš„åˆ†å‰²ç‚¹
    int index = 0;
    while (inorder[index] != root->val)
        index++;

    //é€’å½’
    //é•¿åº¦ï¼š         å·¦  index      å³ inorderSize-index-1
    //å·¦ä¸­åºæ•°ç»„èµ·ç‚¹åœ°å€ï¼šinorder    å³ä¸­åºæ•°ç»„èµ·ç‚¹åœ°å€ï¼šinorder+index+1
    //å·¦å‰åºæ•°ç»„èµ·ç‚¹åœ°å€ï¼špreorder+1 å³å‰åºæ•°ç»„èµ·ç‚¹åœ°å€ï¼špreorder+index+1
    root->left = buildTree(preorder+1, index, inorder, index);
    root->right = buildTree(preorder+index+1, inorderSize-index-1, inorder+index+1, inorderSize-index-1);

    return root;
}
```
## ACMæ¨¡å¼
[P0570:æ ¹æ®äºŒå‰æ ‘å‰ä¸­åºåºåˆ—å»ºæ ‘](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0570/)

å®Œæ•´ä»£ç ï¼š
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdlib.h>
#include<stdio.h>
#include<string.h>

typedef struct TreeNode {
	char val;
	struct TreeNode* left;
	struct TreeNode* right;
}TreeNode;

//ååºéå†
void postOrder(TreeNode* root, char* ret, int* size)
{
	if (root == NULL)
		return;
	postOrder(root->left, ret, size);
	postOrder(root->right, ret, size);
	ret[(*size)++] = root->val;
}

//æ ¹æ®å‰ä¸­åºåˆ—å»ºæ ‘
TreeNode* buildTree(char* pre, int preSize, char* in, int inSize)
{
	if (preSize == 0 || inSize == 0)
		return NULL;
	TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
	root->val = pre[0];
	int index = 0;
	while (in[index] != *pre)
		index++;
	root->left = buildTree(pre + 1, index, in, index);
	root->right = buildTree(pre + index + 1, inSize - index - 1, in + index + 1, inSize - index - 1);
	return root;
}

int main(void)
{
	char in[30], pre[30];
	while (scanf("%s %s", pre, in) != EOF)
	{
		int preSize = strlen(pre);
		int inSize = strlen(in);
		TreeNode* root = buildTree(pre, preSize, in, inSize);
		char tmp[30] = {0};
		int size = 0;
		postOrder(root, tmp, &size);
		tmp[size] = '\0';
		printf("%s", tmp);
		putchar('\n');
	}
}
```
# ğŸ‰ğŸ‰ğŸ‰æ–°å¹´å¿«ä¹
å¸Œæœ›æˆ‘ä»¬éƒ½èƒ½è¶Šæ¥è¶Šå¥½
