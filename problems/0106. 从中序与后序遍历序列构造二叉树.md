# 106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

---
## ğŸ§ æ€è·¯ï¼š
[105.ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://github.com/wunaiqiezixin/Leetcode_Algorithm/blob/main/problems/0105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md)    

---
å®Œæ•´ä»£ç ï¼š
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize) {
    //ç¬¬ä¸€æ­¥ï¼šåˆ¤æ–­æ•°ç»„æ˜¯å¦ä¸ºç©º
    if (!inorderSize) return NULL;
    //ç¬¬äºŒæ­¥ï¼šååºæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ä¸ºå½“å‰æ ¹èŠ‚ç‚¹
    struct TreeNode* curRoot = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    int values = postorder[postorderSize - 1];
    curRoot->val = values;
    //ç¬¬ä¸‰æ­¥ï¼šåœ¨ä¸­åºæ•°ç»„ä¸­æ‰¾åˆ†å‰²ç‚¹
    int index = 0;
    while (inorder[index] != values)
        index++;
    
    //ç¬¬å››æ­¥ï¼šåˆ‡å‰²ä¸­åºæ•°ç»„
    //å·¦ä¸­åºæ•°ç»„èµ·ç‚¹åœ°å€ä¸ºinorder, é•¿åº¦ä¸º index
    //å³ä¸­åºæ•°ç»„èµ·ç‚¹åœ°å€ä¸ºinorder+index+1, é•¿åº¦ä¸º inorderSize - index - 1

    //ç¬¬äº”æ­¥ï¼šåˆ‡å‰²ååºæ•°ç»„--->ä¸¤ä¸ªåŒºé—´çš„é•¿åº¦ä¸ä¸­åºçš„ä¸¤ä¸ªåŒºé—´åŒ
    //å·¦ååºæ•°ç»„çš„èµ·ç‚¹åœ°å€ä¸ºpostorder, é•¿åº¦ä¸º index
    //å³ååºæ•°ç»„çš„èµ·ç‚¹åœ°å€ä¸ºpostorder + index , é•¿åº¦ä¸º inorderSize - index - 1

    //ç¬¬å…­æ­¥ï¼šé€’å½’ï¼Œå·¦å­©å­å¯¹å·¦åŒºé—´ï¼Œå³å­©å­å¯¹å³åŒºé—´
    curRoot->left = buildTree(inorder, index, postorder, index);
    curRoot->right = buildTree(inorder + index + 1,inorderSize - index - 1 , postorder + index, inorderSize - index - 1);
    
    return curRoot;
}
```
### ACMæ¨¡å¼
[P0640:æ ¹æ®äºŒå‰æ ‘ä¸­ååºåºåˆ—å»ºæ ‘](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0640/)

å®Œæ•´ä»£ç ï¼š
### ***C:***
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct TreeNode {
	char val;
	struct TreeNode* left;
	struct TreeNode* right;
}TreeNode;
//å‰åºéå†
void preOrder(TreeNode* root, char* ret, int* size)
{
	if (root == NULL)
		return;
	ret[(*size)++] = root->val;
	preOrder(root->left, ret, size);
	preOrder(root->right, ret, size);
	return;
}

//æ ¹æ®ä¸­ååºåˆ—å»ºæ ‘
TreeNode* buildTree(char* in, int inSize, char* po, int poSize)
{
	if (inSize == 0)
		return NULL;
	TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
	root->val = po[poSize - 1];
	int index = 0;
	while (in[index] != po[poSize - 1])
		index++;
	root->left = buildTree(in, index, po, index);
	root->right = buildTree(in + index + 1, inSize - index - 1,
		                    po + index, inSize - index - 1);
	return root;
}

int main(void)
{
	char in[30], po[30];
	scanf("%s %s", in, po);
	int inSize = strlen(in), poSize = strlen(po);
	TreeNode* root = buildTree(in, inSize, po, poSize);
	char pre[30];
	int size = 0;
	preOrder(root, pre, &size);
	pre[size] = '\0';
	printf("%s", pre);
}
```
