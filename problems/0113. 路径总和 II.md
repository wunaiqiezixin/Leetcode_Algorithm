# 113. è·¯å¾„æ€»å’Œ II
[åŠ›æ‰£é¢˜ç›®é“¾æŽ¥](https://leetcode.cn/problems/path-sum-ii/description/)

---
## ðŸ€é€’å½’æ³•
æœ¬é¢˜çš„é€’å½’å‡½æ•°ä¸éœ€è¦è¿”å›žå€¼ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦å¾ˆå¤šä¸ªæŒ‡é’ˆ(å› ä¸ºåœ¨åŠ›æ‰£ä¸Šåšé¢˜ï¼Œç”¨å…¨å±€å˜é‡ä¸å¤ªå¥½)   
1. å‡½æ•°çš„å‚æ•°
```C
void traversal(struct TreeNode* node, int count, int** ret, int* path, int* retTop, int* pathTop, int* colSize);
//countç”¨äºŽåˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºŽç›®æ ‡å€¼
//retäºŒç»´æ•°ç»„ç”¨äºŽè®°å½•æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„è·¯å¾„
//retTopè¡¨ç¤ºç¬¦åˆæ¡ä»¶çš„è·¯å¾„çš„ä¸ªæ•°
//pathè¡¨ç¤ºä»¥å½“å‰èŠ‚ç‚¹ä¸ºç»ˆç‚¹çš„è·¯å¾„ï¼ŒpathTopè¡¨ç¤ºå…¶é•¿åº¦
//colSizeè¡¨ç¤ºæ¯ä¸€æ¡ç¬¦åˆæ¡ä»¶çš„è·¯å¾„çš„é•¿åº¦
```

2. ç»ˆæ­¢æ¡ä»¶:å¶å­èŠ‚ç‚¹ä¸”count == 0  
è¯´æ˜Žè¯¥è·¯åŠ²ç¬¦åˆæ¡ä»¶ï¼Œå°†pathçš„å€¼æ‹·è´ï¼Œæ”¾å…¥ret
```C
    //ç»ˆæ­¢æ¡ä»¶
    if (!node->left && !node->right && count == 0)
    {
        int* tmpPath = (int*)malloc(sizeof(int) * (*pathTop));
        memcpy(tmpPath, path, (*pathTop) * sizeof(int));
        ret[(*retTop)] = tmpPath;
        colSize[(*retTop)++] = *pathTop;
        return;
    }
```
3. é€’å½’éåŽ†  
```C
    //é€’å½’éåŽ†ï¼šæ³¨æ„å›žæº¯
    if (node->left)
    {
        count -= node->left->val;
        path[(*pathTop)++] = node->left->val;
        traversal(node->left, count, ret, path, retTop, pathTop, colSize);
        count += node->left->val;//å›žæº¯
        (*pathTop)--;//å›žæº¯
    }
    if (node->right)
    {
        count -= node->right->val;
        path[(*pathTop)++] = node->right->val;
        traversal(node->right, count, ret, path, retTop, pathTop, colSize);
        count += node->right->val;//å›žæº¯
        (*pathTop)--;//å›žæº¯
    }
```

å®Œæ•´ä»£ç ï¼š
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
// retè®°å½•ç¬¦åˆæ¡ä»¶çš„æ‰€æœ‰è·¯å¾„
// pathè®°å½•ä¸€æ¡è·¯å¾„
void traversal(struct TreeNode* node, int count, int** ret, int* path, int* retTop, int* pathTop, int* colSize)
{
    //ç»ˆæ­¢æ¡ä»¶
    if (!node->left && !node->right && count == 0)
    {
        int* tmpPath = (int*)malloc(sizeof(int) * (*pathTop));
        memcpy(tmpPath, path, (*pathTop) * sizeof(int));
        ret[(*retTop)] = tmpPath;
        colSize[(*retTop)++] = *pathTop;
        return;
    }
    //é€’å½’éåŽ†ï¼šæ³¨æ„å›žæº¯
    if (node->left)
    {
        count -= node->left->val;
        path[(*pathTop)++] = node->left->val;
        traversal(node->left, count, ret, path, retTop, pathTop, colSize);
        count += node->left->val;//å›žæº¯
        (*pathTop)--;//å›žæº¯
    }
    if (node->right)
    {
        count -= node->right->val;
        path[(*pathTop)++] = node->right->val;
        traversal(node->right, count, ret, path, retTop, pathTop, colSize);
        count += node->right->val;//å›žæº¯
        (*pathTop)--;//å›žæº¯
    }
    return;
}
int** pathSum(struct TreeNode* root, int targetSum, int* returnSize, int** returnColumnSizes) {
    //åˆ†é…ç©ºé—´
    int** ret = (int**)malloc(sizeof(int*) * 1000);
    int* colSize = (int*)malloc(sizeof(int) * 1000);
    int* path = (int*)malloc(sizeof(int) * 1000);
    int retTop = 0, pathTop = 0;

    if (root == NULL) return ret;

    //é€’å½’
    path[pathTop++] = root->val;//æå‰åŠ å…¥æ ¹èŠ‚ç‚¹çš„è·¯å¾„
    traversal(root, targetSum - root->val, ret, path, &retTop, &pathTop, colSize);

    *returnSize = retTop;
    *returnColumnSizes = colSize;

    return ret;
}
```
