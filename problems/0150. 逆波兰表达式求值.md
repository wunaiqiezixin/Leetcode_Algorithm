# 150. é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

### ğŸ§ ç”¨æ ˆè¿™ç§æ•°æ®ç»“æ„
1. é‡åˆ°æ•°å­—å°±å…¥æ ˆ
2. é‡åˆ°è¿ç®—ç¬¦å°±ä»æ ˆç§å¼¹å‡ºä¸¤ä¸ªå…ƒç´ ï¼Œæ ¹æ®è¿ç®—ç¬¦æ±‚å‡ºä¸¤ä¸ªæ•°çš„å€¼ï¼Œå°†è¿™ä¸ªå€¼åœ¨åŠ å…¥æ ˆä¸­
3. æ³¨æ„ï¼Œè¦ç”¨åå¼¹å‡ºçš„æ•°å‡å»å…ˆå¼¹å‡ºçš„æ•°ï¼Œä¸¤æ•°ç›¸é™¤åŒç†
### ***C:***
```C
//å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•´æ•°
int str_to_int(char* s)
{
    int len = strlen(s);
    int tens = 1, ret = 0;
    for (int i = len - 1; i >= 0; i--)
    {
        if (s[i] == '-')
        {
            ret *= -1;
            break;
        }
        ret += tens * (s[i] - '0');
        tens *= 10;
    }
    return ret;
}

//ç”¨ä¸€ä¸ªæ•°ç»„å®ç°ä¸€ä¸ªæ ˆ
int evalRPN(char** tokens, int tokensSize) {
    //åˆ†é…ç©ºé—´
    int* stkNum = (int*)malloc(sizeof(int) * tokensSize);
    int top = 0;//æŒ‡å‘æ ˆé¡¶
    //éå†
    int num1, num2;
    int i;
    for (i = 0; i < tokensSize; i++)
    {
        //å…ˆå¤„ç†è¿ç®—ç¬¦çš„æƒ…å†µ
        char symbol = tokens[i][0];
        if (symbol < '0' && tokens[i][1] == '\0')//è¿ç®—ç¬¦çš„ASIIç æœ€å¤§47ï¼Œå‡å°äº'0'çš„48
        {
            //å–å‡ºä¸¤ä¸ªæ•°å­—
            num1 = stkNum[--top];
            num2 = stkNum[--top];
            switch (symbol)
            {
                case '+':
                    stkNum[top++] = num1 + num2;
                    break;
                case '-'://ä¸¤æ•°ç›¸å‡è¦æ³¨æ„é¡ºåº
                    stkNum[top++] = num2 - num1;
                    break;
                case '*':
                    stkNum[top++] = num1 * num2;
                    break;
                case '/'://ä¸¤æ•°ç›¸é™¤ä¹Ÿè¦æ³¨æ„é¡ºåº
                    stkNum[top++] = num2 / num1;
                    break;
            }
        }
        else//é‡åˆ°æ•°å­—å°±å…¥æ ˆ
        {
            stkNum[top++] = str_to_int(tokens[i]);
        }
    }
    //æœ€åæ ˆä¸­çš„å…ƒç´ å°±æ˜¯ç­”æ¡ˆ
    int ret = stkNum[0];
    free(stkNum);
    return ret;
}
```
