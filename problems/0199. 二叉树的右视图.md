# 199. äºŒå‰æ ‘çš„å³è§†å›¾
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/binary-tree-right-side-view/description/)
---
## ğŸ§ æ€è·¯
æœ¬é¢˜å°±æ˜¯è€ƒå¯Ÿå±‚åºéå†ï¼Œå…ˆå­¦ä¼š [0102.äºŒå‰æ ‘çš„å±‚åºéå†]()   
æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—  
ä»ä¸Šå¾€ä¸‹å±‚åºéå†ï¼Œç”¨sizeè®°å½•æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°é‡ï¼Œåªå°†æ¯ä¸€å±‚æœ€å³è¾¹çš„èŠ‚ç‚¹æ”¾å…¥æ•°ç»„ä¸­  
### ğŸ–ï¸å®Œæ•´ä»£ç 
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* rightSideView(struct TreeNode* root, int* returnSize) {
    //åˆ†é…è¶³å¤Ÿçš„ç©ºé—´
    int* ret = (int*)malloc(sizeof(int) * 100);
    *returnSize = 0;
    //ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—
    struct TreeNode** que = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 100);
    int front = 0, rear = 0;//ç»´æŠ¤é˜Ÿåˆ—çš„å¤´å°¾æŒ‡é’ˆ
    int size = 0;//æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°é‡
    //æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
    if (root == NULL) return ret;
    que[rear++] = root;
    //å‘ä¸‹éå†
    while (front < rear)
    {
        //è®¡ç®—å‡ºå½“å‰å±‚çš„èŠ‚ç‚¹æ•°é‡
        size = rear - front;
        //å°†å·¦è¾¹çš„èŠ‚ç‚¹å…¨éƒ¨å‡ºé˜Ÿ,å¹¶å°†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ä»å·¦åˆ°å³å…¥é˜Ÿ
        while (size != 1)
        {
            struct TreeNode* cur = que[front++];
            size--;
            if (cur->left)
                que[rear++] = cur->left;
            if (cur->right)
                que[rear++] = cur->right;
        }
        //å°†æœ€å³è¾¹çš„èŠ‚ç‚¹å‡ºé˜Ÿï¼Œè®°å½•å…¶å€¼
        struct TreeNode* cur = que[front++];
        //ä¸‹ä¸€å±‚èŠ‚ç‚¹å…¥é˜Ÿ
        if (cur->left)
            que[rear++] = cur->left;
        if (cur->right)
            que[rear++] = cur->right;
        //è®°å½•æ¯ä¸€å±‚æœ€å³è¾¹èŠ‚ç‚¹çš„å€¼
        ret[(*returnSize)++] = cur->val;
    }
    return ret;
}
```
