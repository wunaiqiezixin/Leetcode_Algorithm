# 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

---
## ğŸ§ æ€è·¯
p,qçš„å…¬å…±ç¥–å…ˆçš„å€¼ä¸€å®šåœ¨ p->val å’Œ q->val ä¹‹é—´    
ä»æ ¹èŠ‚ç‚¹å¾€ä¸‹éå†ï¼Œå½“è¾¾åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼åœ¨p->valå’Œq->valä¹‹é—´æ—¶ï¼Œ å®ƒå°±æ˜¯på’Œqçš„æœ€è¿‘å…¬å…±ç¥–å…ˆ     
äºæ˜¯è¿™é¢˜å°±å˜æˆäº†åœ¨äºŒå‰æœç´¢æ ‘ä¸­æŸ¥æ‰¾ä¸€ä¸ªèŠ‚ç‚¹çš„é—®é¢˜ï¼Œä¸”è¿™ä¸ªèŠ‚ç‚¹çš„å€¼åœ¨p->valå’Œq->valä¹‹é—´     


## ğŸ€é€’å½’

### ***C:***
å®Œæ•´ä»£ç ï¼š
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    int M = max(p->val, q->val);
    int m = min(p->val, q->val);
    //ç»ˆæ­¢æ¡ä»¶
    if (m <= root->val && root->val <= M)
    {
        return root;//å°†ç¥–å…ˆè¿”å›ç»™ä¸Šä¸€å±‚
    }
    else if (root->val > M)
    {
        return lowestCommonAncestor(root->left, p, q);
    }
    else
    {
        return lowestCommonAncestor(root->right, p, q);
    }
}
```
## ğŸš€è¿­ä»£æ³•
### ***C:***
å®Œæ•´ä»£ç ï¼š
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) > (b) ? (b) : (a))
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    int m = min(p->val, q->val);
    int M = max(p->val, q->val);
    //è¿­ä»£æ³•
    while (true)
    {
        if (root->val > M)
            root = root->left;
        else if (root->val < m)
            root = root->right;
        else   
            break;
    }
    return root;
}
```
