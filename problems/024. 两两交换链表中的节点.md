# 24. 两两交换链表中的节点
[力扣题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
## 循环迭代
* 要特别清楚，要交换两个结点，就要找到他们两的前一个结点
* 要交换最前面的两个结点，就要找到他们两的前一个结点，所以要用虚拟头结点
* cur 初始时指向虚拟头结点，表示要交换下两个结点
* cur一定指向要交换的两结点的前面
* 所以循环的终止条件为while (cur->next != NULL && cur->next->next != NULL)
* 交换前要先保存cur->next结点，在交换过程种特别要注意代码顺序
### ***C***
```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* swapPairs(struct ListNode* head) {
    //设置虚拟头结点
    struct ListNode dummy;
    dummy.next = head;
    struct ListNode* cur = &dummy;
    while (cur->next && cur->next->next)
    {
        //保存cur->next结点
        struct ListNode* tmp = cur->next;
        //注意代码顺序及指针的变化
        cur->next = tmp->next;
        tmp->next = cur->next->next;
        cur->next->next = tmp;
        //改变cur，使其指向下两个要交换的结点之前
        cur = tmp;
    }
    return dummy.next;
}
```
## 递归
* 链表的定义本身就有递归的思想，链表的题目都可以考虑递归
* 递归的终止：head == NULL || head->next == NULL
* 先做一步：

  nxt = head->next;记录头结点的下一个结点

  head->next = swapPairs(nxt->next);

  nxt->next = head; return nxt;

### ***C***
```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* swapPairs(struct ListNode* head) {
    //递归实现
    if (head == NULL || head->next == NULL) return head; // 递归边界
    //先做一步 + 递归
    struct ListNode* nxt = head->next;/*记录结点*/
    head->next = swapPairs(nxt->next);
    nxt->next = head;
    return nxt;
}
```
