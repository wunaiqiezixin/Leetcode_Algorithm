# 283.移动零
* [力扣题目链接](https://leetcode.cn/problems/move-zeroes/submissions/687637150/)
## 删除数组元素：
* 要删除下标为i的元素，则需将其后面的元素位置都向前移动一位
* 双指针法，用slow记录要保留元素的下标位置，fast寻找要保留的元素，每找到一个元素，则nums[slow++] = nums[fast]
* 双向指针法（不推荐）
  ## 暴力法
  
  ### **C:**
```C
void moveZeroes(int* nums, int numsSize) {
    // 暴力法：
    int i,j;
    int n = numsSize;
    for (i = 0;i < n - 1;i++)
    {
        if (nums[i] == 0)
        {
            for (j = i;j < n - 1;j++)
            {
                nums[j] = nums[j+1];
            }
            nums[n-1] = 0;
            n--;
            i--;
        }
    }
}
```

 ###  **Python:**
```Python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i,n = 0,len(nums)
        while i < n - 1:
            if nums[i] == 0:
                for j in range(i,n - 1):
                    nums[j] = nums[j+1]
                nums[n-1] = 0
                n -= 1
                i -= 1
            i += 1
```

## 双指针法
### **C:**
```C
void moveZeroes(int* nums, int numsSize) {
    int slow = 0,fast = 0;
    while (fast < numsSize)
    {
        if (nums[fast] != 0)
        {
            nums[slow++] = nums[fast];
            
        }
        fast++;
    }
    while (slow < numsSize)
    {
        nums[slow++] = 0;
    }
}
```
### **Python:**
```Python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        slow = fast = 0
        while fast < len(nums):
            if nums[fast] != 0:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        while slow < len(nums):
            nums[slow] = 0
            slow += 1
```
