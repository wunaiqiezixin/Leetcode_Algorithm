# 349. 两个数组的交集

提示：

- 1 <= nums1.length, nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 1000

---
- 给出了数组中数字范围0~1000 ，可以用哈希法，用数组实现
- 定义数组，在力扣中，避免将数组定义为全局变量
```C
_Bool hashTable[1001] = {0};
//在力扣（LeetCode）上提交代码时，使用全局的 hashTable导致出错，核心原因在于力扣的评测系统会使用同一个程序实例连续运行多个测试用例
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {
}
````
- 将hashTable定义为局部变量
```C
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {
_Bool hashTable[1001] = {0};
}
```

---
- 初始化返回数组长度为0，并为返回数组分配空间(两个数组的长度最小值)
```C
*returnSize = 0;
int less = nums1Size > nums2Size ? nums2Size : nums1Size;
int* ans = (int*)malloc(sizeof(int) * less);
```
- 遍历第一个数组，将出现的数字的标记为1
```C
int i;
for (i = 0;i < nums1Size;i++)
{
    hashTable[nums1[i]] = 1;
}
```
- 遍历第二个数组，若数字再次出现，则加入ans,注意加入后的数字标记为0,避免重复加入
```C
for (i = 0;i < nums2Size;i++)
{
    if (hashTable[nums2[i]] == 1)
    {
        ans[(*returnSize)++] = nums2[i];
        hashTable[nums2[i]] = 0;
    }
}
```
## 完整代码
### ***C:***
```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {
    _Bool hashTable[1001] = {0};//记录数组中的数字是否出现
    *returnSize = 0; //返回数组长度初始化为0
    int less = nums1Size > nums2Size ? nums2Size : nums1Size;
    //给结果数组分配空间,两个数组长度的最小值
    int* ans = (int*)malloc(sizeof(int) * less);
    int i;
    for (i = 0;i < nums1Size;i++) 
    {
        hashTable[nums1[i]] = 1;//若数字在数组1中出现，记为1
    }
    for (i = 0;i < nums2Size;i++)
    {
        if (hashTable[nums2[i]] == 1) //若数字也在数组2中出现，则加入结果数组ans
        {
            ans[(*returnSize)++] = nums2[i];
            hashTable[nums2[i]] = 0; //加入ans后将其设为0，防止重复加入
        }
    }
    return ans;
}
```
