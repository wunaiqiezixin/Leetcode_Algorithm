# 429. N å‰æ ‘çš„å±‚åºéå†
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/)

---
## ğŸ§ æ€è·¯
è¦å…ˆå­¦ä¼š[0102.äºŒå‰æ ‘çš„å±‚åºéå†](https://github.com/wunaiqiezixin/Leetcode_Algorithm/blob/main/problems/0102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md)
## ğŸ“ä»£ç 
### ***C:***
```C
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {
    //åˆ†é…è¶³å¤Ÿçš„ç©ºé—´
    int** ret = (int**)malloc(sizeof(int*) * 1001);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 10000);
    *returnSize = 0;
    //é˜Ÿåˆ—
    struct Node** que = (struct Node**)malloc(sizeof(struct Node*) * 10000);
    int front = 0, rear = 0;
    int size = 0;//æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°é‡
    //æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
    if (root == NULL) return ret;
    que[rear++] = root;
    while (front < rear)
    {
        //è®¡ç®—è¿™ä¸€å±‚çš„èŠ‚ç‚¹æ•°é‡
        (*returnColumnSizes)[(*returnSize)] = size = rear - front;
        int* tmp = (int*)malloc(sizeof(int) * 10000);
        int cnt = 0;
        while (size--)
        {
            //å°†è¿™ä¸€å±‚çš„èŠ‚ç‚¹éƒ½å‡ºé˜Ÿ
            struct Node* cur = que[front++];
            tmp[cnt++] = cur->val;
            //å°†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹å…¥é˜Ÿ
            for (int i = 0; i < cur->numChildren; i++)
            {
                que[rear++] = cur->children[i];
            }
            if (!size)//æœ¬å±‚èŠ‚ç‚¹å…¨éƒ¨å¤„ç†å®Œ
            {
                ret[(*returnSize)++] = tmp;
            }
        }
    }
    return ret;
}
```
