# 454. 四数相加 II
[力扣题目链接](https://leetcode.cn/problems/4sum-ii/description/)

- 本题只要找出不同四元组的个数即可，四元组为数组下标的四元组，下标对应的值相同不会被认为重复，因为我们关注的是下标

---
### 解法1
- 用数组和链表实现一个哈希表
```C
#define HASH_SIZE 101 /*用质数作为数组长度*/
//定义一个"桶"(链表节点)
typedef struct node {
    int val;
    int count;
    struct node* next;
}node, *HashMap;
//哈希函数
int hashFunc(int val)
{
    return abs(val) % HASH_SIZE;
}
//哈希表的插入
void hash_insert(HashMap hashmap[], int val)
{
    int idx = hashFunc(val);/*映射到对应数组下标*/
    node* p = hashmap[idx];  /*p指向链表虚拟头节点*/
    while (p->next)//确保p不为野指针
    {
        p = p->next;
        if (p->val == val) 
        {
            (p->count)++;
            return;
        }
    }
    node* new = (node*)malloc(sizeof(node));
    new->val = val;
    new->count = 1;
    new->next = NULL;
    p->next = new;
}
//哈希表的查找
int hash_search(HashMap hashmap[], int val)
{
    int idx = hashFunc(val);
    node* p = hashmap[idx];
    while (p->next)
    {
        p = p->next;
        if (p->val == val) return p->count;
    }
    return 0;
}
```
- 哈希表的初始化，为每个头节点分配空间，让其指向NULL，避免成为野指针
```C
//初始化一个哈希表
    HashMap hashmap[HASH_SIZE];
    for (int i = 0; i < HASH_SIZE; i++)
    {
        hashmap[i] = (node*)malloc(sizeof(node));
        hashmap[i]->next = NULL;//避免虚拟头节点为野指针
    }
```
- 先遍nums1,nums2;再遍历nums3,nums4
```C
//遍历nums1,nums2并记录两数之和
    for (i = 0; i < nums1Size; i++)
    {
        for (j = 0; j < nums2Size; j++)
        {
            int twoSum = nums1[i] + nums2[j];
            hash_insert(hashmap, twoSum);
        }
    }
    //遍历nums3,nums4，统计ans
    for (i = 0; i < nums3Size; i++)
    {
        for (j = 0; j < nums4Size; j++)
        {
            int target = 0 - nums3[i] - nums4[j];
            ans += hash_search(hashmap, target);//ans统计满足情况的元组个数
        }
    }
    return ans;
```
### 完整代码
### ***C:***
```C
int fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size) {
    int i, j, ans = 0;
    //初始化一个哈希表
    HashMap hashmap[HASH_SIZE];
    for (int i = 0; i < HASH_SIZE; i++)
    {
        hashmap[i] = (node*)malloc(sizeof(node));
        hashmap[i]->next = NULL;//避免虚拟头节点为野指针
    }
    //遍历nums1,nums2并记录两数之和
    for (i = 0; i < nums1Size; i++)
    {
        for (j = 0; j < nums2Size; j++)
        {
            int twoSum = nums1[i] + nums2[j];
            hash_insert(hashmap, twoSum);
        }
    }
    //遍历nums3,nums4，统计ans
    for (i = 0; i < nums3Size; i++)
    {
        for (j = 0; j < nums4Size; j++)
        {
            int target = 0 - nums3[i] - nums4[j];
            ans += hash_search(hashmap, target);
        }
    }
    return ans;
}
```
---
---
### 解法2
- 使用**Python字典**,用count 计数
```Python
visited = dict()
count = 0
```
- 先遍历数组A、数组B，将 a + b (数组A某个元素的值 + 数组B某个元素的值) 作为key , 其出现次数作为value 存入visited
```Python
for a in nums1:
    for b in nums2:
        visited[a + b] = visited.get(a + b, 0) + 1
```
- 再遍历数组C、数组D ，并判断0 - (c + d) 是否在visited 中
- 若在，则 count += visited[ 0 - (c + d) ]
```Python
for a in nums3:
    for b in nums4:
        if 0 - (c + d) in visited:
            couont += visited[0 - (c + d)]
```
### 完整代码
### ***Python:***
```Python
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        #用字典统计前两个数组，key：数值，value：出现次数
        visited = dict()
        count = 0
        #遍历nums1,nums2
        for i in nums1:
            for j in nums2:
                visited[i + j] = visited.get(i + j, 0) + 1
        #遍历nums3,nums4
        for i in nums3:
            for j in nums4:
                if -(i + j) in visited:
                    count += visited[-(i + j)]
        return count
```
    
