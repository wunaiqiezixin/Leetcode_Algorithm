# 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

---
## ğŸ§ æ€è·¯
äºŒå‰æœç´¢æ ‘ä¸­åºéå†æœ‰åº    
æˆ‘ä»¬ä¼˜å…ˆè¿›è¡Œä¸­åºéå†    
æœ€å¸¸è§çš„æ–¹æ³•æ˜¯éå†ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡æ±‚å‡ºä¼—æ•°å‡ºç°çš„æ•°ï¼Œç¬¬äºŒæ¬¡æ”¶é›†æ‰€æœ‰ä¼—æ•°    
ä½†æ˜¯å…¶å®éå†ä¸€æ¬¡å°±å¤Ÿäº†ï¼Œåˆå§‹åŒ–```maxCount = 0``` , ```count = 1``` , ç»“æœé›† ```int* ret``` , å½“count>maxCountæ—¶å°±æ¸…ç©ºç»“æœé›†ï¼Œå¹¶å°†å½“å‰èŠ‚ç‚¹çš„å€¼åŠ å…¥ç»“æœé›†    
è¿™æ ·æˆ‘ä»¬å°±åªéœ€è¦éå†ä¸€æ¬¡    

### ğŸ€é€’å½’
### å»ºè®®ï¼š

- æ°¸è¿œä¸è¦åœ¨åŠ›æ‰£çš„é€’å½’å‡½æ•°ä¸­ä½¿ç”¨å…¨å±€å˜é‡æˆ–é™æ€å˜é‡ï¼Œé™¤éé¢˜ç›®æ˜ç¡®è¦æ±‚ã€‚è¿™æ˜¯å› ä¸ºåŠ›æ‰£çš„è¯„æµ‹ç³»ç»Ÿä¼šè¿ç»­è¿è¡Œæµ‹è¯•ç”¨ä¾‹ï¼Œä½†ä¸ä¸€å®šæ¯æ¬¡éƒ½ä¼šé‡ç½®å…¨å±€å˜é‡, å¯¼è‡´çŠ¶æ€æ±¡æŸ“ã€‚
- ç”¨æŒ‡é’ˆä»£æ›¿

å®Œæ•´ä»£ç ï¼š
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
//ç”¨æŒ‡é’ˆï¼Œä¸ç”¨å…¨å±€å˜é‡
void traversal(struct TreeNode* node, int* count, int* maxCount, struct TreeNode** pre, int* result, int* top)
{
    //ç»ˆæ­¢æ¡ä»¶
    if (node == NULL)
        return;
    //å·¦
    traversal(node->left, count, maxCount, pre, result, top);
    //ä¸­
    if (*pre == NULL)//å¤„ç†ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
        *count = 1;
    else if ((*pre)->val == node->val)//ç›¸ç­‰
        (*count)++;
    else //ä¸ç›¸ç­‰
        *count = 1;
    *pre = node;//ä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹
    if (*count == *maxCount)
    {
        result[(*top)++] = node->val;
    }
    else if (*count > *maxCount)
    {
        //æ¸…ç©ºæ•°ç»„
        *top = 0;
        //æ›´æ–°æœ€å¤§å€¼
        *maxCount = *count;
        //åŠ å…¥å½“å‰çš„æœ€å¤§é¢‘ç‡çš„å…ƒç´ 
        result[(*top)++] = node->val;
    }
    //å³
    traversal(node->right, count, maxCount, pre, result, top);
    return;
}
int* findMode(struct TreeNode* root, int* returnSize) {
    struct TreeNode* pre = NULL;
    int count, maxCount = 0;
    int* result = (int*)malloc(sizeof(int) * 10000);
    int top = 0;
    traversal(root, &count, &maxCount, &pre, result, &top);
    *returnSize = top;
    return result;
}
```
### ğŸš€è¿­ä»£æ³•
ä»£ç å’Œé€’å½’æ— åŒºåˆ«

å®Œæ•´ä»£ç ï¼š
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findMode(struct TreeNode* root, int* returnSize) {
    //æ ˆ
    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    int stackTop = 0;
    //è¿­ä»£æ³•-ä¸­åºéå†
    struct TreeNode* cur = root;//ç”¨äºéå†äºŒå‰æ ‘
    struct TreeNode* pre = NULL;//ç”¨äºè®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
    int* ret = (int*)malloc(sizeof(int) * 10000);
    int count = 0, maxCount = 0;
    while (stackTop || cur)
    {
        //å·¦
        if (cur)
        {
            stack[stackTop++] = cur;
            cur = cur->left;
        }
        else
        {
            //å‡ºæ ˆ
            cur = stack[--stackTop];
            //ä¸­
            if (pre == NULL)//å¤„ç†ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
                count = 1;
            else if (pre->val == cur->val)
                count++;
            else    
                count = 1;

            if (maxCount == count)
            {
                ret[(*returnSize)++] = cur->val;
            }
            else if (count > maxCount)
            {
                //æ¸…ç©ºæ•°ç»„å¹¶æ›´æ–°æœ€å¤§é¢‘ç‡
                *returnSize = 0;
                maxCount = count;
                ret[(*returnSize)++] = cur->val;//æ›´æ–°ä¼—æ•°
            }
            pre = cur;
            
            //å³
            cur = cur->right;
        }
    }
    return ret;
}
```
