# 513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

---
## ğŸ“è¿­ä»£æ³•
### å±‚åºéå†
æœ€ç›´æ¥çš„æƒ³æ³•å°±æ˜¯å±‚åºéå†   
åªè¦ç”¨ä¸€ä¸ªresultå˜é‡è®°å½•æ¯ä¸€å±‚æœ€å·¦è¾¹çš„å€¼ï¼Œä¸æ–­æ›´æ–°ï¼Œç›´åˆ°éå†åˆ°æœ€åä¸€å±‚  

å®Œæ•´ä»£ç ï¼š
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int findBottomLeftValue(struct TreeNode* root) {
    //é˜Ÿåˆ—
    struct TreeNode** que = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10000);
    int front = 0, rear = 0;
    int size, result;
    //æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
    que[rear++] = root;
    //ä¸€å±‚ä¸€å±‚éå†
    while (front < rear)
    {
        size = rear - front;
        result = que[front]->val;//æ¯å±‚æœ€å·¦è¾¹çš„èŠ‚ç‚¹çš„å€¼
        while (size--)
        {
            struct TreeNode* cur = que[front++];
            if (cur->left)
                que[rear++] = cur->left;
            if (cur->right)
                que[rear++] = cur->right;
        }
    }
    return result;
}
```
## ğŸ€é€’å½’æ³•
éå†é¡ºåºï¼šä¼˜å…ˆå‘å·¦ï¼Œå³ç¡®ä¿æ¯ä¸€å±‚æœ€å…ˆè¢«éå†åˆ°çš„èŠ‚ç‚¹æ˜¯æœ€å·¦è¾¹çš„   
å³è¦ä¿è¯ï¼š
```C
traversal(node->left);  //å†™åœ¨å‰
traversal(node->right); //å†™åœ¨å
```
1. å‡½æ•°çš„å‚æ•°ä¸è¿”å›å€¼
 
æœ€å·¦è¾¹çš„å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬è¦ç¡®ä¿æ˜¯æœ€å·¦è¾¹çš„ï¼Œäºæ˜¯æˆ‘ä»¬è¦çŸ¥é“éå†åˆ°çš„æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦   
å› ä¸ºæ¯ä¸€å±‚æœ€å…ˆéå†åˆ°çš„å°±æ˜¯æœ€å·¦è¾¹çš„    
å³æ·±åº¦æœ€å…ˆè¾¾åˆ°æœ€å¤§çš„å¶å­èŠ‚ç‚¹å°±æ˜¯æœ€å·¦è¾¹çš„å¶å­èŠ‚ç‚¹  
```C
//depthä¸ºéå†åˆ°çš„èŠ‚ç‚¹æ·±åº¦ï¼ŒmaxDepthä¸ºéå†åˆ°çš„æœ€å¤§æ·±åº¦ï¼Œ retå­˜æ”¾ç»“æœ
void traversal(struct TreeNode* node, int depth, int* maxDepth, int* ret);
```
2. ç»ˆæ­¢æ¡ä»¶

å½“éå†åˆ°æ·±åº¦å¤§äºå½“å‰æœ€å¤§æ·±åº¦çš„å¶å­èŠ‚ç‚¹æ—¶ï¼Œæ›´æ–°æœ€å¤§æ·±åº¦å¹¶è®°å½•è¯¥å¶å­èŠ‚ç‚¹çš„å€¼
```C
    //ç»ˆæ­¢æ¡ä»¶
    if (node == NULL) return;
    if (!node->left && !node->right && depth > *maxDepth)
    {
        *maxDepth = depth;//æ›´æ–°æœ€å¤§æ·±åº¦
        *ret = node->val;//å­˜æ”¾ç»“æœ
        return;
    }
```
3. é€’å½’éå†

ä¼˜å…ˆå‘å·¦
```C
traversal(node->left, depth + 1, maxDepth, ret);//éšè—ç€å›æº¯
traversal(node->right, depth + 1, maxDepth, ret);//éšè—ç€å›æº¯
```

å®Œæ•´ä»£ç ï¼š
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
//depthä¸ºéå†åˆ°çš„èŠ‚ç‚¹æ·±åº¦ï¼ŒmaxDepthä¸ºéå†åˆ°çš„æœ€å¤§æ·±åº¦ï¼Œ retå­˜æ”¾ç»“æœ
void traversal(struct TreeNode* node, int depth, int* maxDepth, int* ret)
{
    //ç»ˆæ­¢æ¡ä»¶
    if (node == NULL) return;
    if (!node->left && !node->right && depth > *maxDepth)
    {
        *maxDepth = depth;//æ›´æ–°æœ€å¤§æ·±åº¦
        *ret = node->val;//å­˜æ”¾ç»“æœ
        return;
    }
    traversal(node->left, depth + 1, maxDepth, ret);//éšè—ç€å›æº¯
    traversal(node->right, depth + 1, maxDepth, ret);//éšè—ç€å›æº¯
}
int findBottomLeftValue(struct TreeNode* root) {
    int ret = 0, maxDepth = -1;
    traversal(root, 1, &maxDepth, &ret);
    return ret;
}
```
