# 589.Nå‰æ ‘çš„å‰åºéå†
[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/)

---
å…ˆå­¦ä¼š [0144.äºŒå‰æ ‘çš„å‰åºéå†](https://github.com/wunaiqiezixin/Leetcode_Algorithm/blob/main/problems/0144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.md)  
Nå‰æ ‘çš„å‰åºéå†ï¼šå…ˆéå†æ ¹èŠ‚ç‚¹ï¼Œå†ä»å·¦åˆ°å³éå†æ ¹èŠ‚ç‚¹çš„å­©å­æ ‘
### ğŸ“é€’å½’å®ç°
### ***C:***
```C
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
//å‰åºï¼šä¸­-å·¦åˆ°å³, é€’å½’è§£å†³
void preOrder(struct Node* treeNode, int* ret, int* retSize)
{
    //éå†æ ¹èŠ‚ç‚¹
    if (treeNode == NULL) return;
    ret[(*retSize)++] = treeNode->val;
    //ä»å·¦åˆ°å³éå†å®ƒçš„å­æ ‘
    for (int i = 0; i < treeNode->numChildren; i++)
    {
        preOrder(treeNode->children[i], ret, retSize);
    }
    return;
}
int* preorder(struct Node* root, int* returnSize) {
    int* ret = (int*)malloc(sizeof(int) * 10000);
    *returnSize = 0;
    preOrder(root, ret, returnSize);
    return ret;
}
```
