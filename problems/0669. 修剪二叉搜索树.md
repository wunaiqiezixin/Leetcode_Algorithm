# 669. 修剪二叉搜索树
[力扣题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

---
## 🍀递归
采用分解问题的思路：有返回值的递归    
充分利用二叉搜索树的性质：左子树 < 根节点 < 右子树   
当遍历到的节点值大于```high```时，可以直接丢弃它的右子树，修剪它的左子树并返回给上一层      
当遍历到的节点值小于```low```时，可以直接丢弃它的左子树，修剪它的右子树并返回给上一层   
### ***C:***
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 /*分解问题的思路*/
//定义：传入一棵树的根节点和一个范围，将范围外的节点丢弃，返回新的根节点
struct TreeNode* trimBST(struct TreeNode* root, int low, int high) {
    //终止条件:（要对整棵树修剪）
    if (root == NULL) return root;

    //如果根节点的值小于下限
    if (root->val < low)
    {
        return trimBST(root->right, low, high);//将修建后的右子树返回给上一层
    }
    //如果根节点的值大于上限
    else if (root->val > high)
    {
        return trimBST(root->left, low, high);//将修剪后的左子树返回给上一层
    }
    //如果在范围内
    root->left = trimBST(root->left, low, high);//接住返回上来的左子树
    root->right = trimBST(root->right, low, high);//接住返回上来的右子树
    
    return root;
}
```
