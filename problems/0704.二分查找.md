# 704.二分查找
[力扣题目链接](https://leetcode.cn/problems/binary-search/?envType=problem-list-v2&envId=binary-search)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。

***你必须编写一个具有 O(log n) 时间复杂度的算法。***


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9

输出: 4

解释: 9 出现在 nums 中并且下标为 4

示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2

输出: -1

解释: 2 不存在 nums 中因此返回 -1
# **常见问题**：
<ol>
    <li>
        while (left <= right) 还是 while (left < right) ?
    </li>
    <li>
        right = mid 还是 right = mid + 1 ?
    </li>
</ol> 
            
# **解答**：
  <ul>
      <li>
          明确查找区间是[left,right], 还是[left,right)。
      </li>
      <li>
          若为[left,right], 则 while (left <= right) | mid = right + 1
      </li>
        <li>
            若为[left,right), 则 while (left < right) | mid = right
        </li>
                <li>
                    在循环中保持不变
                </li>
  </ul>


## 左闭右闭：
### **C:**

```c
int search(int* nums, int numsSize, int target) {
    int left = 0,right = numsSize - 1;
    int mid;
    while (left <= right)
    {
        mid = left + (right - left);
        if (nums[mid] == target)
        {
            return mid;
        }
        else if (nums[mid] < target)
        {
            left = mid + 1;
        }
        else
        {
            right = mid - 1;
        }
    }
    return -1;
}
```
### **Python:**
```Python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left,right = 0,len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] > target:
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                return mid
        return -1 
```

## 左闭右开：
### **C:**
```C
int search(int* nums, int numsSize, int target) {
    int left = 0,right = numsSize;
    int mid;
    while (left < right)
    {
        mid = left + (right - left) / 2;
        if (nums[mid] < target)
        {
            left = mid + 1;
        }
        else if (nums[mid] > target)
        {
            right = mid;
        }
        else
        {
            return mid;
        }
    }
    return -1;
}
```

### **Python:**
```Python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left,right = 0,len(nums)
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        return -1
```
## 相关题目

* [35.搜索插入位置](https://programmercarl.com/0035.搜索插入位置.html)
* [34.在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html)
* [69.x 的平方根](https://leetcode.cn/problems/sqrtx/)
* [367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

## 扩展：
* [网线主管](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0120/)
* [Aggressive cows](http://cxsjsxmooc.openjudge.cn/dspythonbookqh2/P0130/)



