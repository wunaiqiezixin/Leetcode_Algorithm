# 108. 将有序数组转换为二叉搜索树
[力扣题目链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

---
将有序数组的中点作为根节点的值，中点的左侧作为左子树，右侧作为右子树，进行递归    
[具体思路](https://github.com/wunaiqiezixin/Leetcode_Algorithm/blob/main/problems/0105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md)
```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* sortedArrayToBST(int* nums, int numsSize) {
    //终止条件：数组为空
    if (numsSize == 0) return NULL;
    //分割有序数组，新建节点
    int idx = numsSize / 2;//分割点
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val = nums[idx];
    root->left = sortedArrayToBST(nums, idx);//接住来自下面的节点
    root->right = sortedArrayToBST(nums + idx + 1, numsSize - idx - 1);//接住来自下面的节点
    return root;
}
```
