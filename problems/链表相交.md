# 面试题 02.07. 链表相交
[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)
## 思路：
* 其实有的时候想太多了反而不好
* 因为这道题，分别求出两个链表的长度就是一种很好的方法
* 有时想不出好办法了，多遍历几次链表，求出长度，说不定就解决了
### ***C***
```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode* p;
    struct ListNode* q;
    //下面求两个链表的长度
    int lenA = 0,lenB = 0,gap = 0;
    p = headA;
    while (p)
    {
        lenA++;
        p = p->next;
    }
    q = headB;
    while (q)
    {
        lenB++;
        q = q->next;
    }
    //使p指针指向长链表的头结点，q指针指向锻炼表的头结点
    if (lenA > lenB)
    {
        p = headA;
        q = headB;
        gap = lenA - lenB;
    }
    else
    {
        p = headB;
        q = headA;
        gap = lenB - lenA;
    }
    //将p指针移动gap步，使p,q指针对齐
    while (gap--)
    {
        p = p->next;
    }
    //p、q指针一起移动，判断是否相等
    while (p != q && p)
    {
        p = p->next;
        q = q->next;
    }
    return p; // 返回相交的第一个结点，没有则返回NULL;
}
```
### 双指针法
* p指向headA
* q指向headB
* 只要p != q , p,q指针同时移动
* 只要p,q指针没有指向NULL,就同时向下移动一位
* 不然的话，
* p指向headB
* q指向headA
* 最后p，必然指向同一处，要么是NULL，要么是第一个相交的结点
### ***C***
```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    //优雅的双指针法
    if (!headA || !headB) return NULL;

    struct ListNode* p;
    struct ListNode* q;
    
    p = headA;
    q = headB;
    while (p != q)
    {
        p = p ? p->next : headB;
        q = q ? q->next : headA;
    }
    return p;
}
```
